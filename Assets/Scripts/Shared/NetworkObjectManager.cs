using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;

/// Manages the lifecycle of network-active objects.
public class NetworkObjectManager : MonoBehaviour {
  private static ushort nextId = 1;

  public NetworkObject basePlayerPrefab;
  public NetworkObject remotePlayerPrefab;
  public NetworkObject hitscanAttackPrefab;

  // Currently managed network objects indexed by their network ID.
  private Dictionary<ushort, NetworkObject> activeObjects;

  // Whether the manager is authoritative. Authoritative means network IDs are
  // generated by this manager, otherwise they are required to be present.
  private bool isAuthoritative;

  private void Start() {
    activeObjects = new Dictionary<ushort, NetworkObject>();
  }

  public NetworkObject GetObject(ushort networkId) {
    return activeObjects[networkId];
  }

  public List<NetworkObject> GetActiveNetworkObjects() {
    return new List<NetworkObject>(activeObjects.Values);
  }

  // Ensure that the network ID is valid, or return a new network ID if zero is given
  // and the manager is authoritative.
  private ushort EnsureNetworkId(ushort networkId) {
    if (networkId > 0) {
      Assert.IsFalse(isAuthoritative, "Manager is authoritative, a network ID is unexpected.");
      return networkId;
    }
    Assert.IsTrue(isAuthoritative, "Manager is not authoritative, a network ID is expected.");
    if (nextId >= ushort.MaxValue) {
      throw new System.Exception("Maximum number of network objects reached!");
    }
    return nextId++;
  }

  public void SetAuthoritative(bool isAuthoritative) {
    this.isAuthoritative = isAuthoritative;
  }

  public NetworkObject CreatePlayerGameObject(ushort networkId, Vector3 position, bool isRemote) {
    networkId = EnsureNetworkId(networkId);
    var prefab = isRemote ? remotePlayerPrefab : basePlayerPrefab;
    var obj = Instantiate(prefab, position, Quaternion.identity);
    obj.NetworkId = networkId;
    activeObjects[networkId] = obj;
    return obj;
  }

  public void DestroyNetworkObject(NetworkObject obj) {
    Destroy(obj.gameObject);
    activeObjects.Remove(obj.NetworkId);
  }

  public void DestroyNetworkObject(ushort networkId) {
    try {
      Destroy(activeObjects[networkId]);
    } catch (KeyNotFoundException) {
      this.LogError($"Couldn't destroy non-existant network object #{networkId}");
    }
  }

  public NetworkObject SpawnPlayerObject(
      ushort networkId, NetworkObjectType type, Vector3 position, Quaternion orientation,
      bool forLocalPlayer = false) {
    if (type != NetworkObjectType.HITSCAN_ATTACK) {
      throw new NotImplementedException();
    }

    var obj = Instantiate(hitscanAttackPrefab, position, orientation);

    // For local players we skip the network ID for now.
    // TODO - We'll still need to track this and assign it to the server network ID later.
    if (!forLocalPlayer) {
      obj.NetworkId = EnsureNetworkId(networkId);
      activeObjects[obj.NetworkId] = obj;
    }

    return obj;
  }

  public void Clear() {
    activeObjects.Clear();
  }
}
